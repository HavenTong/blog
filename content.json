{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"About","text":"The essential thing is not to have conquered but to have fought well.","link":"/about/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"FIRST AK","text":"纪念一下人生第一次AK: 后续题解会尽快补充","link":"/2020/05/16/FIRST-AK/"},{"title":"C++-priority_queue","text":"C+±priority_queue C++ STL-priority_queue 用法 priority_queue存在于头文件&lt;queue&gt;中，以下代码解释了该容器如何使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct Node{ int a,b; Node(){} Node(int aa,int bb):a(aa),b(bb){} // 二级排序，a相同时按照b升序排序，否则按照a升序排序 // (a,b): (1,1)&lt;(1,2)&lt;(2,1)&lt;(2,2) // 这里重载的大于号和小于号在逻辑上等价 bool operator &lt; (const Node &amp;r) const{ if(a==r.a) return b&lt;r.b; else return a&lt;r.a; } bool operator &gt; (const Node &amp;r) const{ if(a==r.a) return b&gt;r.b; else return a&gt;r.a; }};int main(){ //priority_queue 是基于堆实现的优先队列 // .size()返回当前优先队列的元素个数 // empty()为true表示当前队列为空，false表示不空 priority_queue&lt;int&gt; tmp_q; cout&lt;&lt;tmp_q.size()&lt;&lt;endl; //0 cout&lt;&lt;tmp_q.empty()&lt;&lt;endl; //1 tmp_q.push(1); cout&lt;&lt;tmp_q.size()&lt;&lt;endl; //1 cout&lt;&lt;tmp_q.empty()&lt;&lt;endl; //0 tmp_q.pop(); cout&lt;&lt;tmp_q.size()&lt;&lt;endl; //0 cout&lt;&lt;tmp_q.empty()&lt;&lt;endl; //1 // priority_queue&lt;int&gt; 表示队列中存储的元素是int类型（STL模板类） // 默认priority_queue表示队列按照less出队 // 后出队的元素比先出队的元素要小，出队的元素越来越小，所以是less // push 加入元素 // top 返回队首元素 // pop 队首元素出队 priority_queue&lt;int&gt; q; q.push(5); q.push(6); cout&lt;&lt;q.top()&lt;&lt;endl; //6 q.pop(); cout&lt;&lt;q.top()&lt;&lt;endl; //5 q.pop(); // greater 表示后出队的元素比先出队的元素要大, 出队的元素越来越大，所以是greater priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q_greater; // &lt;&gt;中第二个参数vector&lt;int&gt;表示优先队列中使用vector&lt;int&gt; 存储元素，可以更换成deque // 第二个参数中更换的其他类型应支持.begin(),.end(),.push(),.pop()等操作 // 绝大多数情况都使用vector&lt;&gt;，极少需要更换 // 例子：priority_queue&lt;int, deque&lt;int&gt;, greater&lt;int&gt;&gt; q_greater; q_greater.push(5); q_greater.push(6); cout&lt;&lt;q_greater.top()&lt;&lt;endl; //5 q_greater.pop(); cout&lt;&lt;q_greater.top()&lt;&lt;endl; //6 q_greater.pop(); // 更换为double类型，出队法则是less priority_queue&lt;double, vector&lt;double&gt;, less&lt;double&gt;&gt; q_less; q_less.push(5.2); q_less.push(6.6); cout&lt;&lt;q_less.top()&lt;&lt;endl; //6.6 q_less.pop(); cout&lt;&lt;q_less.top()&lt;&lt;endl; //5.2 q_less.pop(); // 自定义类Node的priority_queue 使用greater需要对元素重载大于号 priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; q_greater_node; q_greater_node.push(Node(1,1)); q_greater_node.push(Node(1,2)); q_greater_node.push(Node(2,1)); q_greater_node.push(Node(2,2)); cout&lt;&lt;q_greater_node.top().a&lt;&lt;\" \"&lt;&lt;q_greater_node.top().b&lt;&lt;endl; // 1 1 q_greater_node.pop(); cout&lt;&lt;q_greater_node.top().a&lt;&lt;\" \"&lt;&lt;q_greater_node.top().b&lt;&lt;endl; // 1 2 q_greater_node.pop(); cout&lt;&lt;q_greater_node.top().a&lt;&lt;\" \"&lt;&lt;q_greater_node.top().b&lt;&lt;endl; // 2 1 q_greater_node.pop(); cout&lt;&lt;q_greater_node.top().a&lt;&lt;\" \"&lt;&lt;q_greater_node.top().b&lt;&lt;endl; // 2 2 q_greater_node.pop(); // 自定义类Node的priority_queue 使用less需要对元素重载小于号 priority_queue&lt;Node, vector&lt;Node&gt;, less&lt;Node&gt;&gt; q_less_node; q_less_node.push(Node(1,1)); q_less_node.push(Node(1,2)); q_less_node.push(Node(2,1)); q_less_node.push(Node(2,2)); cout&lt;&lt;q_less_node.top().a&lt;&lt;\" \"&lt;&lt;q_less_node.top().b&lt;&lt;endl; // 2 2 q_less_node.pop(); cout&lt;&lt;q_less_node.top().a&lt;&lt;\" \"&lt;&lt;q_less_node.top().b&lt;&lt;endl; // 2 1 q_less_node.pop(); cout&lt;&lt;q_less_node.top().a&lt;&lt;\" \"&lt;&lt;q_less_node.top().b&lt;&lt;endl; // 1 2 q_less_node.pop(); cout&lt;&lt;q_less_node.top().a&lt;&lt;\" \"&lt;&lt;q_less_node.top().b&lt;&lt;endl; // 1 1 q_less_node.pop(); return 0;}","link":"/2019/11/18/C++-priority-queue/"},{"title":"HappyNewYear","text":"Happy New Year 今年的最后10分钟，又是自己独自面对着电脑。 没有什么别的愿望，只是希望2020年别再像2019这么烂了。 ​ 2019.12.31 23:55","link":"/2019/12/31/HappyNewYear/"},{"title":"Happy Birthday","text":"Happy Birthday to myself! Hope the goal will finally be achieved!","link":"/2020/06/27/Happy-Birthday/"},{"title":"Machine Learning-Concepts","text":"Machine Learning-Concepts 1. 数据 大写字母表示举证，大写字母表示向量 数据整体叫数据集(data set) 每一行数据称为一个样本(sample) 每一个字段表达样本的一个特征(feature) 第i个样本写作 $ X^{(i)} $ ，第i个样本第j个特征值写作 $X^{(i)}_j $ 学习的任务：标记(label), 表示为 $ y $, 第 $i$ 个样本的标记写作 $ y^{ (i) } $ 第 $i$ 行，也就是第 $i$ 个样本，也被称作特征向量 $ X^{ (i) } $ $$ X^{(i)} = \\left( \\begin{matrix} 5.1 \\ 3.5 \\ 1.4 \\ 0.2 \\end{matrix} \\right) $$ 数学中通常把向量表示成列向量，所以通常特征可以表示成如下的形式: $$ \\left( \\begin{matrix} (X^{ (1)} )^T \\ (X^{ (2)} )^T \\ (X^{ (3)} )^T \\end{matrix} \\right) $$ 所有特征所存在的空间，称为特征空间(feature space) 分类任务的本质就是特征空间的划分 在高维空间同理 特征可以很抽象 图像中，每一个像素点都是特征，e.g. 28 * 28的图像就有28 * 28 = 784个特征 如果彩色图像特征更多 2. 基本任务 监督学习主要处理分类和回归问题 分类 二分类 判断邮件是否是垃圾邮件 判断发放给客户信用卡是否有风险 判断肿瘤是恶性还是良性 判断股票涨跌 多分类 数字识别 图像识别 判断发放给客户的信用卡的风险评级 很多复杂的问题可以转换成多分类问题 一些算法只支持二分类的任务，但多分类的任务可以转换成二分类的任务 一些算法天然可以完成多分类任务 多标签分类 e.g. 对图片中的元素进行划分 回归 结果是一个连续数字的值，而非一个类别 房屋价格 市场分析 学生成绩 股票价格 有一些算法只能解决回归问题，有一些算法只能解决分类问题，有一些算法都可以解决 一些情况下，回归任务可以简化为分类任务 流程 模型 $f(x)$ 3. 机器学习分类 监督学习 给机器的训练数据拥有&quot;标记&quot;or&quot;答案&quot; 图片已经拥有了标定信息 银行已经积累了一定的客户信息和他们信用卡的信用情况 医院已经积累了一定的病人信息和他们最终确诊是否患病的情况 市场积累了房屋的基本信息和最终成交的金额 非监督学习 给机器的训练数据没有任何&quot;标记&quot;或者“答案” 对没有&quot;标记&quot;的数据进行分类-聚类分析 意义 对数据进行降维处理 特征提取：信用卡的信用评级和人的胖瘦无关？ 特征压缩(特征之间关系很强)：PCA 降维处理可以方便可视化 异常检测 半监督学习 一部分数据标有&quot;标记&quot;或者&quot;答案&quot;，另一部分数据没有 更常见：各种原因产生的标记缺失 通常都先使用无监督学习手段对数据做处理，之后使用监督学习手段做模型的训练和预测 增强学习 根据周围环境的情况，采取行动，根据采取行动的结果，学习行动方式 行动-反馈 奖赏或惩罚机制 4. 机器学习的其他分类 批量学习(Batch Learning) 优点：简单 问题：如何适应环境变化？ 解决方案：定时重新批量学习 缺点：每次重新批量学习，运算量巨大；同时，在某些环境变化非常快的情况下，甚至不可能 在线学习(Online Learning) 输入样例和正确结果迭代进入机器学习算法 优点：及时反映新的环境变化 问题：新的数据带来不好的变化？ 解决方案：需要加强对数据进行监控 其他：也适用于数据量巨大，无法完全批量学习的环境 参数学习(Parametric Learning) e.g. 假设模型定为 $f(x) = ax + b$，那么机器学习的任务就是找到合适的 $a$ 和 $b$ 特点：一旦学到了参数，就不再需要原有的数据集 非参数学习(Nonparametric Learning) 不对模型进行过多假设 非参数不代表没有参数","link":"/2020/02/09/Machine-Learning-Concepts/"},{"title":"MongoDB基础","text":"MongoDB基础 123brew services start mongodb-community@4.2brew services stop mongodb-community@4.2 1. 基本概念 集合 集合类似于数组，在集合中可以存放文档 文档 文档是文档数据库的最小单元，我们操作和存储的内容都是文档 在MongoDB中数据库和集合都不需要手动创建 当创建文档时，如果文档所在的集合或数据库不存在，会自动创建集合和数据库 2. 基本指令 show dbs 显示当前所有数据库 use [db names] 进入到指定的数据库中 db 表示当前所处的数据库 show collections 查看数据库中所存在的集合 3. CRUD (1) 插入文档 db.&lt;collection&gt;.insert() 向集合中插入1个或多个文档 向test数据库中的 stus 集合中插入一个新的学生对象 {name: &quot;孙悟空&quot;, age: 18, gender: &quot;male&quot;} 12345db.stus.insert({ name: \"孙悟空\", age: 18, gender: \"male\"}) 向集合中插入文档时，如果没有指定_id属性，则数据库会用ObjectID()自动为文档添加_id，改属性作为文档的唯一标识。 可以自己属性_id，数据库就不会再添加；如果自己指定，也必须确保唯一性 db.&lt;collection&gt;.insertOne() db.&lt;collection&gt;.insertMany() (2) 查询文档 db.&lt;collection&gt;.find() 查询集合中所有符合条件的文档 find()可以接受一个对象作为条件 find({})也表示查询所有文档 {字段名: 值}： 查询字段是指定值的文档 find()返回是一个数组，可以用[]索引 db.&lt;collection&gt;.findOne() 查询集合中符合条件的第一个文档 findOne()返回的是一个文档 db.&lt;collection&gt;.find().count() / db.&lt;collection&gt;.find().length MongoDB支持通过内嵌文档的属性查询，如果要查询内嵌文档，通过.来匹配；如果要通过内嵌文档进行查询，此时属性名必须使用引号 123db.users.find({ \"hobby.movies\": \"hero\"}); .limit()可以设置显示数据的上限 分页数据显示 .skip((页码-1) * 每页显示的条数).limit(每页显示的条数) .skip()用于跳过指定数量的数据 MongoDB会自动调整skip()和limit()的位置 (3) 修改文档 db.&lt;collection&gt;.update(查询条件，新对象) 默认情况下用新对象替换旧对象 12//替换db.stus.update({name: \"haven\"}, {age: 28}) 如果需要修改指定属性，而不是替换，需要使用修改操作符 $set 可以用来修改文档中的指定属性 12345678db.stus.update( {\"_id\" : ObjectId(\"5da96ae4298c2eb5254c4588\")}, {$set:{ gender: \"male\", address: \"liu sha he\" } }) $unset 可以用来删除文档的指定属性 update()默认情况只改一个 db.&lt;collection&gt;.updateMany() 同时修改多个符合条件的文档 db.&lt;collection&gt;.updateOne() 更新第一个符合条件的文档 db.&lt;collection&gt;.replaceOne() 替换一个文档 $push: 向数组中添加一个元素 $addToSet: 向数组中添加一个元素，且没有重复 (4) 删除文档 db.&lt;collection&gt;.remove() 可以根据条件来删除文档，传递的条件的方式和find()一样 默认情况下，删除符合条件的所有文档 如果remove()第二个参数为true，则只会删除一个 如果只传递一个空对象作为参数，则删除全部文档 db.&lt;collection&gt;.deleteOne() db.&lt;collection&gt;.deleteMany() db.&lt;collection&gt;.drop() 删除整个集合 db.dropDatabase()","link":"/2019/10/22/MongoDB%E5%9F%BA%E7%A1%80/"},{"title":"New Theme","text":"更新了Blog的Theme为Icarus:","link":"/2020/05/21/New-Theme/"},{"title":"STL Notes","text":"STL容器共性 STL容器所提供的都是值寓意，而非引用寓意，也就是说当我们向容器插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，也就是说我们提供的元素必须能够拷贝。 若有指针，需要写拷贝构造，重载等号 除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通常STL不会抛出异常，需要使用者传入正确参数。 每个容器都提供了一个默认的构造函数和默认的拷贝构造函数。 大小相关的构造方法： size()返回容器中元素的个数 empty()判断元素是否为空 STL容器使用时机 vector deque list set multiset map multimap 典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树 可随机存取 是 是 否 否 否 对key而言，是 否 元素搜寻速度 慢 慢 非常慢 快 快 对key而言，快 对key而言，快 元素安插移除 尾端 头尾两端 任何位置 - - - - 使用场景 vector 软件历史操作数据的存储，经常查看历史记录，但不会删除记录。 deque 排队购票系统，排队者的存储可以采用deque，支持头部快速移除，尾端快速添加。如果采用vector，头部移除会移动大量数据，速度慢。 vector v.s. deque vector.at()比deque.at()效率高：vector.at(0)是固定的，deque的开始位置是不固定的 如果有大量释放操作时，vector花的时间更少 deque支持头部的快速插入与移除 list 公交车乘客的存储，随时可能有乘客下车，支持频繁的不确定位置元素的移除和插入 set 对手机游戏的个人得分纪录的存储，存储要求从高分到低分的顺序排列 map 按ID号存储十万个用户，想要快速通过ID查找对应的用户。利用二叉树的查找效率。","link":"/2019/07/18/STL-Notes/"},{"title":"STL-map","text":"STL-map 近日做题用到了C++中STL的map容器，在涉及map的排序过程时，通常有两种方式进行排序 Sort by key Sort by value 为了加深这两种排序方式的写法，我又写了一个demo来梳理两种排序方式的写法 map的参数 12345template &lt; class Key, // map::关键字类型 class T, // map::值类型 class Compare = less&lt;Key&gt;, // map::关键字比较函数 class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator类 &gt; class map; Sort by key 升序 默认情况下，map按照key的大小升序排序，即less&lt;Key&gt; 12345678910111213141516void show(map&lt;string, int&gt;&amp; map) { for (auto it = map.begin(); it != map.end(); it++) { cout &lt;&lt; it -&gt; first &lt;&lt; \" \" &lt;&lt; it -&gt; second &lt;&lt; endl; } cout &lt;&lt; \"================================\" &lt;&lt; endl; cout &lt;&lt; endl;} map&lt;string, int&gt; asc_map;asc_map[\"boss\"] = 2;asc_map[\"abuse\"] = 1;asc_map[\"unit\"] = 3;asc_map[\"duty\"] = 4;// map默认按照key的大小升序排列, 即第三个参数为less&lt;string&gt;cout &lt;&lt; \"🚀 DEFAULT: \" &lt;&lt; endl;show(asc_map); 所以打印结果如下: 123456🚀 DEFAULT: abuse 1boss 2duty 4unit 3================================ 降序 我们可以通过修改map的第三个参数来改变排序规则，使map按照Key的降序排列: 12345678910111213141516void show(map&lt;string, int, greater&lt;string&gt;&gt;&amp; map) { for (auto it = map.begin(); it != map.end(); it++) { cout &lt;&lt; it -&gt; first &lt;&lt; \" \" &lt;&lt; it -&gt; second &lt;&lt; endl; } cout &lt;&lt; \"================================\" &lt;&lt; endl; cout &lt;&lt; endl;}// map可以指定按照key的大小升序或降序排列map&lt;string, int, greater&lt;string&gt;&gt; desc_map;desc_map[\"boss\"] = 2;desc_map[\"abuse\"] = 1;desc_map[\"unit\"] = 3;desc_map[\"duty\"] = 4;cout &lt;&lt; \"🚀 DESC:\" &lt;&lt; endl;show(desc_map); 打印结果为: 123456🚀 DESC:unit 3duty 4boss 2abuse 1================================ Sort by value 对map的value进行排序需要借助别的容器，比如vector，将每一个map中的entry放到一个新的vector中，然后使用sort()函数加上自定义比较规则cmp即可对map中的元素按照value进行排序: demo中使用的比较函数将按照value升序排序： 1234567891011121314151617181920212223242526// 升序排列bool cmp(const pair&lt;string, int&gt;&amp; p1, const pair&lt;string, int&gt;&amp; p2) { return p1.second &lt; p2.second;}void sortByValue(map&lt;string, int&gt;&amp; map) { vector&lt;pair&lt;string, int&gt; &gt; data; for (auto it = map.begin(); it != map.end(); it++) { data.push_back(make_pair(it -&gt; first, it -&gt; second)); } sort(data.begin(), data.end(), cmp); for (pair&lt;string, int&gt; p : data) { cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl; } cout &lt;&lt; \"================================\" &lt;&lt; endl; cout &lt;&lt; endl;}// 对map的value进行排序map&lt;string, int&gt; value_sort_map;value_sort_map[\"boss\"] = 2;value_sort_map[\"abuse\"] = 1;value_sort_map[\"unit\"] = 3;value_sort_map[\"duty\"] = 4;cout &lt;&lt; \"🚀 SORT BY VALUE\" &lt;&lt; endl;sortByValue(value_sort_map); 打印结果如下： 123456🚀 SORT BY VALUEabuse 1boss 2unit 3duty 4================================ 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;utility&gt; // 使用make_pair()#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// 升序排列bool cmp(const pair&lt;string, int&gt;&amp; p1, const pair&lt;string, int&gt;&amp; p2) { return p1.second &lt; p2.second;}void sortByValue(map&lt;string, int&gt;&amp; map) { vector&lt;pair&lt;string, int&gt; &gt; data; for (auto it = map.begin(); it != map.end(); it++) { data.push_back(make_pair(it -&gt; first, it -&gt; second)); } sort(data.begin(), data.end(), cmp); for (pair&lt;string, int&gt; p : data) { cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl; } cout &lt;&lt; \"================================\" &lt;&lt; endl; cout &lt;&lt; endl;}void show(map&lt;string, int&gt;&amp; map) { for (auto it = map.begin(); it != map.end(); it++) { cout &lt;&lt; it -&gt; first &lt;&lt; \" \" &lt;&lt; it -&gt; second &lt;&lt; endl; } cout &lt;&lt; \"================================\" &lt;&lt; endl; cout &lt;&lt; endl;}void show(map&lt;string, int, greater&lt;string&gt;&gt;&amp; map) { for (auto it = map.begin(); it != map.end(); it++) { cout &lt;&lt; it -&gt; first &lt;&lt; \" \" &lt;&lt; it -&gt; second &lt;&lt; endl; } cout &lt;&lt; \"================================\" &lt;&lt; endl; cout &lt;&lt; endl;}int main() { map&lt;string, int&gt; asc_map; asc_map[\"boss\"] = 2; asc_map[\"abuse\"] = 1; asc_map[\"unit\"] = 3; asc_map[\"duty\"] = 4; // map默认按照key的大小升序排列, 即第三个参数为less&lt;string&gt; cout &lt;&lt; \"🚀 DEFAULT: \" &lt;&lt; endl; show(asc_map); // map可以指定按照key的大小升序或降序排列 map&lt;string, int, greater&lt;string&gt;&gt; desc_map; desc_map[\"boss\"] = 2; desc_map[\"abuse\"] = 1; desc_map[\"unit\"] = 3; desc_map[\"duty\"] = 4; cout &lt;&lt; \"🚀 DESC:\" &lt;&lt; endl; show(desc_map); // 对map的value进行排序 map&lt;string, int&gt; value_sort_map; value_sort_map[\"boss\"] = 2; value_sort_map[\"abuse\"] = 1; value_sort_map[\"unit\"] = 3; value_sort_map[\"duty\"] = 4; cout &lt;&lt; \"🚀 SORT BY VALUE\" &lt;&lt; endl; sortByValue(value_sort_map); return 0;}","link":"/2020/03/05/STL-map/"},{"title":"Spring Boot Bean自动装配","text":"Spring Boot Bean自动装配 1. 全局配置文件 修改Spring Boot自动配置的默认值，Spring Boot在底层自动加载 application.yml application.properties 2. Bean自动装配原理 (1) Spring Boot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration (2) @EnableAutoConfiguration ​ 作用： 将类路径下META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值(自动装配类)加入到执行计划中 (3) 每一个自动装配类进行自动配置功能 3. YAML规则 (1) 双引号 ​ 不会转义特殊字符，特殊字符或作为本身想要表达的意思 ​ name: &quot;zhangsan \\n lisi&quot; 输出 zhangsan 换行 lisi ​ 单引号 ​ 会转义特殊字符，特殊字符最终只是一个普通的字符串数据，如： ​ name: 'zhangsan \\n lisi' 输出 zhangsan \\n lisi (2) 支持松散的结构 ​ family-name = familyName = family_name (3) 占位符 123456${random.value}${random.int}${random.long}${random.int(10)}${random.int[1024, 65536]}${xxxx.yyyy: 默认值} 4. 获取自定义配置 (1) @Value(&quot;${}&quot;) ​ 实现了单个属性的注入 (2) 对于复杂的数据结构，使用@ConfigurationProperties获取配置值 12345678910111213141516171819202122package com.haven.model.yaml;import lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * @author HavenTong * @date 2019/10/29 5:44 下午 */@Data@Component@ConfigurationProperties(prefix = \"family\")public class Family {// @Value(\"${family.family-name}\") private String familyName; private Father father; private Mother mother; private Child child;} (3) 两种注解区别 @ConfigurationProperties @Value 功能 批量注入属性 一个个指定 松散语法绑定 支持 不支持 SpEL 不支持 支持 复杂数据类型嵌套 支持 不支持 JSR303数据校验 支持 不支持 5. 配置文件注入值数据校验 (1) 在需要校验的属性装配类上加@Validated注解 (2) 数据校验注解列表 (3) 若验证失败，会出现BindValidationException异常 6. Profile不同环境下不同配置 优先级： 外部大于内部，特指大于泛指 application.yml 全局配置文件 application-dev.yml 开发环境配置文件 application-test.yml 测试环境配置文件 Application-prod.yml 生产环境配置文件 (1) 配置application.yml 设置spring.profiles.active指定使用哪一个配置文件。 优先级以下面的dev/test/prod yml为优先 123spring: profiles: active: dev (2) 通过命令行启动 1java -jar SpringBoot01HelloWorld-1.0-SNAPSHOT.jar --spring.profiles.active=dev (3) IDEA设置Program Arguments ​ (a) Edit Configuration --&gt; Environment --&gt; Program Argument 1--spring.profiles.active=dev ​ (b) Edit Configuration --&gt; Environment --&gt; VM options 1-Dspring.profiles.active=dev 7. 项目内部配置文件加载位置 spring boot会扫描以下位置的application.properties / application.yml文件作为spring boot的默认配置文件 1234-file:./config/-file:./-classpath:/config/-classpath:./ 以上优先级从高到低，所有位置的文件都会被加载；高优先级会覆盖低优先级 8. 配置文件敏感字段加密 (1) 与spring boot整合 123456&lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.18&lt;/version&gt; &lt;/dependency&gt; (2) 需要加密的地方，使用ENC()进行包裹处理 (3) 在配置文件中设置密钥","link":"/2019/10/29/Spring-Boot-Bean%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"},{"title":"Spring Boot-CORS","text":"Spring Boot-CORS 什么是跨域？ 定义：浏览器从一个域名的网页取请求另一个域名下的东西。通俗点说，浏览器直接从A域访问B域中的资源是不被允许的，如果想要访问，就需要进行一步操作，这操作就叫“跨域”。例如，你从百度的页面，点击一个按钮，请求了新浪的一个接口，这就进行了跨域。不单单只有域名不同就是跨域，域名、端口、协议其一不同就是不同的域，请求资源需要跨域。 为什么要跨域？ 为什么需要跨域，而不直接访问其他域下的资源呢？这是浏览器的限制，专业点说叫浏览器同源策略限制。主要是为了安全考虑。现在的安全框架，一般请求的时候header中不是都存个token嘛，你要是用这个token去正常访问A域下的东西是没问题的，然后又去访问了B域，结果阴差阳错的还带着这个token，那么B域，或者说B网站是不是就可以拿着你的token去A域下做点什么呢，这就相当危险了。所以浏览器加上了所谓的浏览器同源策略限制。但是为了我们真的需要从A域下访问B的资源（正常访问），就需要用到跨域，跨越这个限制了。 SpringBoot解决跨域问题 SpringBoot可以基于Cors解决跨域问题，Cors是一种机制，告诉我们的后台，哪边（origin ）来的请求可以访问服务器的数据。 全局配置 配置实例如下： 12345678910111213141516@Configurationpublic class CorsConfig { @Bean public WebMvcConfigurer corsConfigurer(){ return new WebMvcConfigurer(){ @Override public void addCorsMappings(CorsRegistry registry){ registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowedMethods(\"POST\", \"GET\", \"PUT\", \"OPTIONS\", \"DELETE\") .allowCredentials(true) .maxAge(3600); } }; }} 首先实现了WebMvcConfigurer接口，WebMvcConfigurer这个接口十分强大，里面还有很多可用的方法，在SpringBoot2.0里面可以解决WebMvcConfigurerAdapter曾经的部分任务。其中一个方法就是addCorsMappings()，是专门为开发人员解决跨域而诞生的接口。其中构造参数为CorsRegistry。 CorsRegistry的源码 123456789101112131415161718public class CorsRegistry { private final List&lt;CorsRegistration&gt; registrations = new ArrayList&lt;&gt;(); public CorsRegistration addMapping(String pathPattern) { CorsRegistration registration = new CorsRegistration(pathPattern); this.registrations.add(registration); return registration; } protected Map&lt;String, CorsConfiguration&gt; getCorsConfigurations() { Map&lt;String, CorsConfiguration&gt; configs = new LinkedHashMap&lt;&gt;(this.registrations.size()); for (CorsRegistration registration : this.registrations) { configs.put(registration.getPathPattern(), registration.getCorsConfiguration()); } return configs; }} 可以看出CorsRegistry有个属性registrations ，按道理可以根据不同的项目路径进行定制访问行为，但是我们示例直接将pathPattern 设置为/**，也就是说已覆盖项目所有路径，只需要创建一个CorsRegistration就好。getCorsConfigurations(),这个方法是获取所有CorsConfiguration的Map集合，key值为传入路径pathPattern。 回到示例代码CorsConfig中，registry对象addMapping()增加完传入路径pathPattern之后，return了一个CorsRegistration对象，是进行更多的配置，看一下CorsRegistration的代码，看看我们能配些什么？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class CorsRegistration { //传入的路径 private final String pathPattern; //配置信息实体类 private final CorsConfiguration config; //构造方法 public CorsRegistration(String pathPattern) { this.pathPattern = pathPattern; //原生注释看到了一个 @CrossOrigin 这个注解，待会看看是什么 // Same implicit default values as the @CrossOrigin annotation + allows simple methods this.config = new CorsConfiguration().applyPermitDefaultValues(); } //允许哪些源网站访问，默认所有 public CorsRegistration allowedOrigins(String... origins) { this.config.setAllowedOrigins(Arrays.asList(origins)); return this; } //允许何种方式访问，默认简单方式，即：GET，HEAD，POST public CorsRegistration allowedMethods(String... methods) { this.config.setAllowedMethods(Arrays.asList(methods)); return this; } //设置访问header，默认所有 public CorsRegistration allowedHeaders(String... headers) { this.config.setAllowedHeaders(Arrays.asList(headers)); return this; } //设置response headers，默认没有（什么都不设置） public CorsRegistration exposedHeaders(String... headers) { this.config.setExposedHeaders(Arrays.asList(headers)); return this; } //是否浏览器应该发送credentials，例如cookies Access-Control-Allow-Credentials public CorsRegistration allowCredentials(boolean allowCredentials) { this.config.setAllowCredentials(allowCredentials); return this; } //设置等待时间，默认1800秒 public CorsRegistration maxAge(long maxAge) { this.config.setMaxAge(maxAge); return this; } protected String getPathPattern() { return this.pathPattern; } protected CorsConfiguration getCorsConfiguration() { return this.config; }} 局部配置 在Controller上加入@CrossOrigin注解 12345678910111213141516171819202122232425262728293031323334353637383940@Target({ ElementType.METHOD, ElementType.TYPE })@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CrossOrigin { /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated String[] DEFAULT_ORIGINS = { \"*\" }; /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated String[] DEFAULT_ALLOWED_HEADERS = { \"*\" }; /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated boolean DEFAULT_ALLOW_CREDENTIALS = false; /** @deprecated as of Spring 5.0, in favor of {@link CorsConfiguration#applyPermitDefaultValues} */ @Deprecated long DEFAULT_MAX_AGE = 1800 /** * Alias for {@link #origins}. */ @AliasFor(\"origins\") String[] value() default {}; @AliasFor(\"value\") String[] origins() default {}; String[] allowedHeaders() default {}; String[] exposedHeaders() default {}; RequestMethod[] methods() default {}; String allowCredentials() default \"\"; long maxAge() default -1;} 这个注解可以作用于方法或者类上，实现局部跨域，你会发现除了设置路径（因为没必要了，都定位到局部了）其他的参数与全局类似。","link":"/2019/11/18/Spring-Boot-CORS/"},{"title":"Spring Boot-IDEA开发技巧","text":"SpringBoot with IDEA 插件 lombok IDEA中下载后 在pom.xml文件中引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 常用注解 12345@Builder@Data@AllArgsConstructor@NoArgsConstructor... GsonFormat 可以快速的将JSON转换为实体类 shortcut option + s 热部署 pom文件中引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; pom文件中引入依赖 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Preferences – Compiler – Build project automatically ✅ cmd + option + shift + / – registry – compiler.automake.allow.when.app.running – ✅ 配置完成后，修改项目文件后会自动build","link":"/2019/10/26/Spring-Boot-IDEA%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"title":"Spring Boot对静态方法进行打桩","text":"Spring Boot对静态方法进行打桩 问题 在对Spring Boot项目进行测试的时候，会对业务逻辑service层进行测试。而service层的代码可能会使用util中的工具类，而工具方法通常来说都是static类型的方法。问题在于，当对service层的代码进行测试时，我们往往需要对静态方法打桩，返回我们需要的结果。然而，主流的测试框架Mockito并不支持对静态方法的打桩。对于此问题，我们需要寻求其他框架的解决方案 解决 1. 首先，通过mockito官方文档的描述，可以发现： What are the limitations of Mockito Cannot mock final classes Cannot mock static methods Cannot mock final methods - their real behavior is executed without any exception. Mockito cannot warn you about mocking final methods so be vigilant. 可以看到，Mockito并不支持mock静态方法，同时也有以下的描述： Can I mock static methods? No. Mockito prefers object orientation and dependency injection over static, procedural code that is hard to understand &amp; change. If you deal with scary legacy code you can use JMockit or Powermock to mock static methods. 通过这样的描述，我们发现其他框架提供了解决方案： JMockit Powermock 之后，由于网上的回答中，Powermock更加主流，且与Mockito的语法相近，于是考虑通过Powermock框架解决问题。 再次查阅了Powermock在github上的项目主页：，得到以下的说明： urrently PowerMock supports JUnit and TestNG. There are three different JUnit test executors available, one for JUnit 4.4-4.12, one for JUnit 4.0-4.3. The test executor for JUnit 3 is not avaliable since PowerMock 2.0. 可以看出，Powermock当前最新版本仅支持到JUnit4.12，而无法对JUnit5提供支持。然而，spring-boot-starter-test中，整合的已是JUnit5. 在网上找寻了众多的回答，所有的例子都是通过JUnit4编写的测试脚本。 且通过Powermock测试的脚本结构如下： 12345@RunWith(PowerMockRunner.class)@PrepareForTest( { YourClassWithEgStaticMethod.class })public class YourTestCase {...} 该结构为JUnit4的写法，并不能在JUnit5中使用。我也尝试强行在Spring Boot项目中单独添加JUnit4依赖，然后单独通过JUnit4来运行通过Powermock编写的测试脚本，多次尝试之后依然无法运行。于是转向另一个框架–JMockit。 2. 尝试通过JMockit来测试静态方法。首先查看JMockit是否支持JUnit5，在官网寻找到了答案： To run tests that use any of the JMockit APIs, use your Java IDE, Maven/Gradle build script, etc. the way you normally would. In principle, any JDK of version 1.7 or newer, on Windows, Mac OS X, or Linux, can be used. JMockit supports (and requires) the use of JUnit (version 4 or 5) or TestNG 既然JMockit支持JUnit5，且可以对静态方法进行打桩，这就是一种可行的解决方案。所以接下来我就去寻找对静态方法进行打桩的实现方案。 在一篇博客中，我发现了解决方案： 首先，需要添加JMockit的依赖，通过mvnrepository添加最新版的JMockit依赖： 1234567&lt;!-- https://mvnrepository.com/artifact/org.jmockit/jmockit --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jmockit&lt;/groupId&gt; &lt;artifactId&gt;jmockit&lt;/artifactId&gt; &lt;version&gt;1.48&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 查看博客中给出的例子： 123456789101112131415161718192021222324252627282930313233// 需要测试的类public class AppManager { public boolean managerResponse(String question) { return AppManager.isResponsePositive(question); } public static boolean isResponsePositive(String value) { if (value == null) { return false; } int length = value.length(); int randomNumber = randomNumber(); return length == randomNumber ? true : false; } private static int randomNumber() { return new Random().nextInt(7); }}// 对静态方法进行打桩@Testpublic void givenAppManager_whenStaticMethodCalled_thenValidateExpectedResponse() { new MockUp&lt;AppManager&gt;() { @Mock public boolean isResponsePositive(String value) { return false; } }; assertFalse(appManager.managerResponse(\"Some string...\"));} 按照类似的写法，完成了我的测试脚本的编写 123456789101112131415161718192021222324@Test@DisplayName(\"发送邮件内容正确\")void shouldSendCorrectEmailWhenUserIsNew(){ // 使用JMockit对静态方法进行打桩 new MockUp&lt;CheckCodeUtil&gt;(){ @mockit.Mock public String generateCheckCode(){ return \"123456\"; } }; when(redisTemplate.opsForValue()).thenReturn(new ValueOperationsFake()); ArgumentCaptor&lt;String&gt; emailCaptor = ArgumentCaptor.forClass(String.class); ArgumentCaptor&lt;String&gt; subjectCaptor = ArgumentCaptor.forClass(String.class); ArgumentCaptor&lt;String&gt; contentCaptor = ArgumentCaptor.forClass(String.class); customerService.sendCheckCode(\"10175101152@stu.ecnu.edu.cn\"); verify(mailService, times(1)) .sendHtmlMail(emailCaptor.capture(), subjectCaptor.capture(), contentCaptor.capture()); assertAll( () -&gt; assertEquals(\"10175101152@stu.ecnu.edu.cn\", emailCaptor.getValue()), () -&gt; assertEquals(\"Registration from MeetHere\", subjectCaptor.getValue()), () -&gt; assertEquals(\"&lt;h1&gt;Welcome to MeetHere!&lt;/h1&gt;&lt;p&gt;Your check code is &lt;u&gt;\" + \"123456\" + \"&lt;/u&gt;&lt;/p&gt;\", contentCaptor.getValue()) );} 编写完毕后，尝试是否可以运行，但是依然报错： 1java.lang.IllegalStateException: JMockit didn't get initialized; please check the -javaagent JVM initialization parameter was used 针对报错信息去Google进行查找，大多数的解决方案是： 1@RunWith(JMockit.class) 这同样是JUnit4的写法。并不能解决我所遇到的问题 再次回到JMockit的官方文档，查看官方文档中给出的运行方法，发现了潜在的解决方案： JMockit also requires the -javaagent JVM initialization parameter to be used; when using the Maven Surefire plugin for test execution, it’s specified as follows: 所以看来想要运行JMockito编写的测试脚本，需要指定-javaagent的JVM参数才可以。 官网给出了方案： 1234567891011&lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.2&lt;/version&gt; &lt;!-- or some other version --&gt; &lt;configuration&gt; &lt;argLine&gt; -javaagent:${settings.localRepository}/org/jmockit/jmockit/${jmockit.version}/jmockit-${jmockit.version}.jar &lt;/argLine&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 将这段xml复制到pom文件中，并将${jmockit.version}替换为项目中使用的1.48 再次运行测试脚本： BINGO!","link":"/2019/12/10/Spring-Boot%E5%AF%B9%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%89%93%E6%A1%A9/"},{"title":"SpringBoot HelloWorld","text":"SpringBoot HelloWorld 一个功能： 浏览器发送一个hello请求，浏览器接受请求并处理，响应hello字符串 1. 创建一个maven工程(jar) 2. 导入SpringBoot相关依赖 maven选择自动导入 12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; (1) 父项目 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;&lt;/parent&gt; 它的父项目是 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt;来真正管理Spring Boot里的所有依赖 SpringBoot的版本仲裁中心； 导入依赖默认不需要写版本(没有在dependencies中进行管理的自然需要声明版本号) (2) 导入的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring-boot-starter-web spring boot场景启动器: 帮我们导入了web模块正常运行所依赖的组件 SpringBoot将所有功能场景都抽取出来，做成一个个starters(启动器)，只需要在项目中引入这些starter，相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 3. 编写主程序 1@SpringBootApplication // 来标注一个主程序类，说明这是一个Spring Boot类 @SpringBootApplication：SpringBoot标注在某个类上，说明这个类是SpringBoot的主配置类。SpringBoot就应该运行这个类的main 方法来启动SpringBoot类。 12345678910111213141516@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication @SpringBootConfiguration：SpringBoot的配置类 标注在某个类上，表示这是一个Spring Boot配置类 @Configuration：配置类上标注这个注解 配置类==配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能 以前我们需要配置的东西，SpringBoot自动帮我们配置 123@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration @AutoConfigurationPackage：自动配置包 @Import({Registrar.class}) Spring的底层注解，@Import给容器中导入一个组件；导入的组件由Registrar.class 将主配置类(@SpringBootApplication标注的类)的所在包及下面所有子包里面的所有组件都扫描到Spring容器中。 @Import({AutoConfigurationImportSelector.class}) 给容器中导入组件， AutoConfigurationImportSelector.class：导入哪些组件的选择器 将所有需要导入的组件以全类名的方式返回； 这些组件就会被添加到容器中； 会给容器中导入非常多的自动配置类(xxxAutoConfiguration)；就是给容器中导入这个场景需要的所有组件，并配置好这些组件 有了自动配置类，就免去了手动编写配置注入功能组件的工作 Spring Boot在启动时从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作 J2EE的整体解决方案和自动配置都在spring-boot-autoconfiguration中 4. 编写相关的Controller, Service 1234567891011121314151617181920package com.haven.Controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @author HavenTong * @date 2019-09-09 00:56 */@Controllerpublic class HelloController { @ResponseBody @RequestMapping(\"/hello\") private String hello(){ return (\"Hello World\"); }} 5. 运行主程序测试 6. 简化部署 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar 11.5 导入Spring Boot的maven插件 123456789&lt;!-- 可以将应用打包成一个可执行的jar包 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 侧边栏—&gt;Maven—&gt;项目—&gt;LifeCycle—&gt;package 1java -jar 进行执行 7. 使用SpringBoot Initializer创建的项目 resources static: 保存的所有静态资源 js, css, 图片 templates: 保存所有的模版页面。(Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持jsp的页面); 可以使用模版引擎(freemarker, thymeleaf); **application.properties: **Spring Boot应用的配置文件","link":"/2019/09/13/SpringBoot-HelloWorld/"},{"title":"SpringBoot-Mybatis","text":"Spring Boot-Mybatis 1. ORM框架选型 对比项 SPRING DATA JPA MYBATIS 单表操作方式 只需继承，代码量较少，非常方便。而且支持方法名用关键字生成SQL 可以使用代码生成工具，也很方便，但相对JPA单表弱很多。JPA单表操作非常简单 多表关联查询 友好，动态SQL使用不够方便，而且SQL和代码耦合到一起 非常友好，可以有非常直观的动态SQL 自定义SQL SQL写在注解里面，写动态SQL有些费劲 SQL可以写在XML里，独立管理，动态SQL语法也容易书写理解 学习成本 略高 较低，会写SQL就可以 JPA是规范，Hibernate是实现 Spring Data JPA 对开发人员更加友好，单表操作非常方便，多表关联也不麻烦 mybatis各方面都很优秀，使用范围更广 大型项目建议mybatis 2. 整合MyBatis操作数据库 pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; mybatis-config.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!-- 配置全局属性--&gt; &lt;settings&gt; &lt;!-- 使用Jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\"/&gt; &lt;!-- 使用列表签替换列别名 --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!-- 开启驼峰命名转换: Table{create_time} -&gt; Entity{createTime} --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 同样的内容也可以写在Spring Boot配置文件application.yml中 1234567891011121314spring: datasource: username: root password: Thwf1858 url: jdbc:mysql://localhost:3306/mybatis driver-class-name: com.mysql.jdbc.Driverlogging: level: com.haven.mybatis.mapper: debugmybatis: configuration: map-underscore-to-camel-case: true use-generated-keys: true use-column-label: true 注解书写SQL 123456789101112131415161718192021222324252627282930313233343536373839package com.hehe.mapper;@Mapperpublic interface UserMapper { /** * 方式1：使用注解编写SQL。 */ @Select(\"select * from t_user\") List&lt;User&gt; list(); /** * 方式2：使用注解指定某个工具类的方法来动态编写SQL. */ @SelectProvider(type = UserSqlProvider.class, method = \"listByUsername\") List&lt;User&gt; listByUsername(String username); /** * 延伸：上述两种方式都可以附加@Results注解来指定结果集的映射关系. * * PS：如果符合下划线转驼峰的匹配项可以直接省略不写。 */ @Results({ @Result(property = \"userId\", column = \"USER_ID\"), @Result(property = \"username\", column = \"USERNAME\"), @Result(property = \"password\", column = \"PASSWORD\"), @Result(property = \"mobileNum\", column = \"PHONE_NUM\") }) @Select(\"select * from t_user\") List&lt;User&gt; listSample(); /** * 延伸：无论什么方式,如果涉及多个参数,则必须加上@Param注解,否则无法使用EL表达式获取参数。 */ @Select(\"select * from t_user where username like #{username} and password like #{password}\") User get(@Param(\"username\") String username, @Param(\"password\") String password); @SelectProvider(type = UserSqlProvider.class, method = \"getBadUser\") User getBadUser(@Param(\"username\") String username, @Param(\"password\") String password);} 可以传入参数 JavaBean Map 多个参数，需要用@Param注解 @Results注解 123456789@Select(\"select t_id, t_age, t_name \" + \"from sys_user \" + \"where t_id = #{id} \") @Results(id=\"userResults\", value={ @Result(property=\"id\", column=\"t_id\"), @Result(property=\"age\", column=\"t_age\"), @Result(property=\"name\", column=\"t_name\"), }) User selectUserById(@Param(\"id\") String id); @Results可以给出一个id，其他方法根据该id可以通过@ResultMap重复使用： 12345@Select(\"select t_id, t_age, t_name \" + \"from sys_user \" + \"where t_name = #{name} \") @ResultMap(\"userResults\") User selectUserByName(@Param(\"name\") String name);","link":"/2019/11/07/SpringBoot-Mybatis/"},{"title":"SpringBoot RESTful接口","text":"SpringBoot RESTful接口 1.常用注解开发RESTful接口 @RestController 将注解的类注入到Spring的环境 相当于@Controller + @ResponseBody JSON格式的数据响应 @RequestMapping 类上的注解表示注解的Controller类的路径 @PathVariable 路径上的变量 @PathVariable &amp; RequestParam @PathVariable用于接收URL上的{参数} @RequestParam用于接收普通方式提供的参数 @RequestBody &amp; @RequestParam JSON数据建议用@RequestBody,会分配实体类中的所有属性 @RequestParam适合接收单个的参数 @RequestBody可以接收嵌套的数据结构 2.JSON数据处理和Postman测试 Spring Boot默认使用Jackson (1) 常用注解 @JsonIgnore：加在属性上表示在序列化和反序列化的过程中将它忽略 @JsonProperty：为属性起别名 @JsonPropertyOrder：加在类上 @JsonInclude(JsonInclude.Include.NON_NULL): 当属性不为空的时候，进行序列化；否则不进行 @JsonFormat(pattern = &quot;&quot;, timezone = &quot;&quot;)：配置时间格式 1234spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 (2) 序列化与反序列化 把对象转成可传输、可存储的格式(json, xml, 二进制，甚至自定义的格式)叫序列化，反序列化为逆过程 3. Postman使用 4. 使用Swagger 2发布API文档 代码变，文档变，只需要少量的注解，使用Swagger就可以根据代码自动生成API文档，很好地保持了文档的及时性 跨语言性，支持40多种语言 Swagge UI呈现出一份可交互式的API文档，我们可以直接在文档页面尝试API的调用，省去了准备复杂的 调用参数的过程 还可以将文档规范导入相关的工具(e.x. SoapUI)，这些工具会为我们创建自动化的测试 整合Swagger 2 pom.xml 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142// config/Swagger2.javapackage com.haven.config;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.w3c.dom.DocumentType;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author HavenTong * @date 2019/10/29 3:26 下午 */@Configuration@EnableSwagger2public class Swagger2 { @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.haven\")) .paths(PathSelectors.regex(\"/rest/.*\")) .build(); } private ApiInfo apiInfo(){ return new ApiInfoBuilder() .title(\"springboot利用swagger构建api文档\") .description(\"简单优雅的restfun风格\") .termsOfServiceUrl(\"http://www.zimug.com\") .version(\"1.0\") .build(); }} 之后启动项目，通过http://localhost:8080/swagger-ui.html即可访问swagger-ui 可以在方法上添加更详细的注解： 12345678910111213 @ApiOperation(value = \"添加文章\", notes = \"添加新的文章\", tags = \"Article\", httpMethod = \"POST\")// @ApiImplicitParams({// @ApiImplicitParam(name = \"title\", value = \"文章标题\", required = true, dataType = \"String\"),// @ApiImplicitParam(name = \"content\", value = \"文章内容\", required = true, dataType = \"String\"),// @ApiImplicitParam(name = \"author\", value = \"文章作者\", required = true, dataType = \"String\")// }) @ApiResponses({ @ApiResponse(code = 200, message = \"成功\", response = AjaxResponse.class), @ApiResponse(code = 400, message = \"用户输入错误\", response = AjaxResponse.class), @ApiResponse(code = 500, message = \"系统内部错误\", response = AjaxResponse.class) }) @RequestMapping(value = \"/article\", method = RequestMethod.POST, produces = \"application/json\") public AjaxResponse saveArticle(@RequestBody Article article){ 由于采用@RequestBody去接收参数，这里就不需要使用@ApiImplicitParam注解，@ApiImplicitParam注解与@RequestParam注解是一一对应的。 建议有Swagger 2的情况下，减少与此对应的代码注释或不写 Swagger 2常用注解 @Api：用在请求的类上，表示对类的说明 ​ tags=“说明该类的作用，可以在UI界面上看到的注解” ​ value=“该参数没有什么意义，在UI界面上也能看到，所以不需要配置” @ApiOperation: 用在请求的方法上，说明方法的用途、作用 ​ value=“说明方法的用途，作用” ​ notes=“方法的备注说明” @ApiImplicitParams: 用在请求的方法上，表示一组参数说明 ​ @ApiImplicitParam: 用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 ​ name=“参数名” ​ value=“参数的汉字说明，解释” ​ required=“参数是否必须要传” ​ paramType=“参数放在哪个地方” ​ - header --&gt; 请求参数的获取：@RequestHeader ​ - query --&gt; 请求参数的获取：@RequestParam ​ - path(用于restful接口) --&gt; 请求参数的获取: @PathVariable ​ - body,form不常用 ​ dataType= “参数类型”，默认String, 其他值dataType=&quot;Integer&quot; ​ defaultValue= “参数的默认值” @ApiResponses: 用在请求的方法上，表示一组响应 ​ @ApiResponse: 用在@ApiResponses中，一般用于表达一个错误的响应信息 ​ code= 数字，e.x. 400 ​ message= 信息，例如&quot;请求参数没填好&quot; ​ response= 抛出异常的类 @ApiModel: 用于响应类上，表示一个返回响应数据的信息。(这种一般用在post创建的时候, 使用@RequestBody的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候) ​ @ApiModelProperty: 用在属性上，描述响应类的属性 ​ ​","link":"/2019/10/29/SpringBoot-RESTful%E6%8E%A5%E5%8F%A3/"},{"title":"Topological-Sort","text":"拓扑排序 近日实现了一下拓扑排序，在这里记录一下拓扑排序的思想，并附上一个具体的题目 这里使用bfs实现 思想 对一个有向无环图(DAG-Directed Acyclic Graph)G进行拓扑排序，将G中的所有顶点拍成一个线性序列，使得图中任何一对顶点u和v，若(u, v) 属于 E(G)，则u在线性序列中出现在v之前。 也就是说，由某集合上的偏序得到这个集合的全序 步骤 计算所有节点的入度(in-degree) 将所有入度为0的节点加入一个队列 然后出队，得到一个元素 将该元素指向的所有节点的入度都减1 在减的过程中，如果其减后为0则将该元素也加入队列 继续进行步骤3，直到队列为空 运用 除了以上提到的用途，还可以判断有向图中是否有环： 根据出队元素的个数，若出队元素的个数等于图中节点的个数，则该图无环；否则该有向图存在环 例题 hdu-1285 题目大意就是进行拓扑排序，来获得比赛的名次，但是名次的排列要按照最小的字典序–即同等排名的元素，编号小的放在前面，这里使用了两种方式 使用priority_queue代替queue 保证每次出队的元素都是最小的那个，具体AC代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;int n, m;vector&lt;int&gt; topSort(vector&lt;vector&lt;int&gt; &gt;&amp; G){ vector&lt;int&gt; result; // 记录每个节点的入度 vector&lt;int&gt; in(n + 1, 0); for (int i = 1; i &lt; G.size(); i++) { for (int j = 0; j &lt; G[i].size(); j++) { in[G[i][j]]++; } } // 使用优先队列，保证每次出队的元素最小 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int &gt; &gt; queue; // 第一次入队，所有in-degree为0的节点 for (int i = 1; i &lt; in.size();i ++) { if (in[i] == 0) { queue.push(i); } } while (!queue.empty()) { int current = queue.top(); queue.pop(); // 出队元素存到排序结果中 result.push_back(current); // 将所有current指向的节点的in-degree全部-1 for (int i = 0; i &lt; G[current].size(); i++) { in[G[current][i]]--; // 如果减到0则入队 if (in[G[current][i]] == 0) { queue.push(G[current][i]); } } } return result;}int main() { while (cin &gt;&gt; n &gt;&gt; m) { vector&lt;vector&lt;int&gt; &gt; G(n + 1); int a, b; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); } vector&lt;int&gt; result = topSort(G); for (int i = 0; i &lt; result.size(); i++) { cout &lt;&lt; result[i] &lt;&lt; ((i == result.size() - 1) ? \"\" : \" \"); } cout &lt;&lt; endl; }} 对于in-degree，每次从头开始寻找in-degree为0的节点，所以每次找到的都是当前编号最小的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n, m;// 存放结果int ans[505];void topSort(vector&lt;vector&lt;int&gt;&gt;&amp; G) { vector&lt;int&gt; in(n + 1); for (int i = 0; i &lt; G.size(); i++) { for (int j = 0; j &lt; G[i].size(); j++) { in[G[i][j]]++; } } for (int i = 1; i &lt;= n; i++) { // 每次从in数组的头部开始查找，那么每次找到的都是当前编号最小的节点 int k = 1; while (in[k] != 0){ k++; } ans[i] = k; // 将in[k]赋值为-1来表示删除节点 in[k] = -1; // 将k连接的所有节点的in-degree都-1 for (int j = 0; j &lt; G[k].size(); j++) { in[G[k][j]]--; } }}int main() { while (cin &gt;&gt; n &gt;&gt; m) { memset(ans, 0, sizeof(ans)); int a, b; vector&lt;vector&lt;int&gt; &gt; G(n + 1); for (int i = 0; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); } topSort(G); for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans[i] &lt;&lt; ((i == n ) ? \"\" : \" \"); } cout &lt;&lt; endl; } return 0;}","link":"/2020/03/06/Topological-Sort/"},{"title":"Vue实例的生命周期","text":"什么是生命周期 从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件统称为生命周期。 生命周期钩子 生命周期事件的别名 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类 创建期间的生命周期函数 beforeCreate 实例刚在内存中被创建出来，此时还没有初始化好data和methods属性。只有默认的生命周期函数和默认的事件 created 实例在内存中已创建ok，data和method已创建ok。此时还没有开始编译模版 beforeMount 此时已经完成了模版的编译，但是还没有挂载到页面中 mounted 此时已经将编译好的模版挂载到了页面指定的容器中使用 运行期间的生命周期函数 beforeUpdate 状态更新之前执行此函数，此时data的状态是最新的，但是页面上显示的数据还是旧的，此时还没有重新渲染DOM节点 updated 实例更新完毕后调用此函数，此时data的状态值和界面上显示的数据都已经完成了更新，界面已经被重新渲染完毕 销毁期间的生命周期函数 beforeDestroy 实例销毁之前调用，在这一步，实例依然完全可用 destroyed Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁","link":"/2019/07/20/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"[Hexo] Theme BeanTech","text":"Ported Theme of Hux Blog, Thank Huxpro for designing such a flawless theme. This BeanTech theme created by YuHsuan modified from the original Porter Kaijun Usage I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog! Let’s begin!!! Init 123git clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantechcd hexo-beantechnpm install Modify Modify _config.yml file with your own info. Especially the section: Deployment Replace to your own repo! 1234deploy: type: git repo: https://github.com/&lt;yourAccount&gt;/&lt;repo&gt; branch: &lt;your-branch&gt; Sidebar settings Copy your avatar image to &lt;root&gt;/img/ and modify the _config.yml: 123sidebar: true # whether or not using Sidebar.sidebar-about-description: \"&lt;your description&gt;\"sidebar-avatar: img/&lt;your avatar path&gt; and activate your personal widget you like 1234567widgets: # here are widget you can use, you can comment out- featured-tags- short-about- recent-posts- friends-blog- archive- category if you want to add sidebar widget, please add at layout/_widget. Signature Setup Copy your signature image to &lt;root&gt;/img/signature and modify the _config.yml: 12signature: true # show signaturesignature-img: img/signature/&lt;your-signature-ID&gt; Go to top icon Setup My icon is using iron man, you can change to your own icon at css/image. Post tag You can decide to show post tags or not. 1home_posts_tag: true 1home_posts_tag: false Markdown render My markdown render engine plugin is hexo-renderer-markdown-it. 12345678910# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' and if you want to change the header anchor ‘ℬ’, you can go to layout/post.ejs to change it. 123456async(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){ anchors.options = { visible: 'hover', placement: 'left', icon: ℬ // this is the header anchor \"unicode\" icon }; Hexo Basics Some hexo command: 1234hexo new post \"&lt;post name&gt;\" # you can change post to another layout if you wanthexo clean &amp;&amp; hexo generate # generate the static filehexo server # run hexo in local environmenthexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo! Have fun ^_^ Please Star this Project if you like it! Follow would also be appreciated! Peace!","link":"/2017/03/18/hexo-theme-beantech/"},{"title":"redis.conf","text":"redis.conf 绑定的主机地址 1bind 127.0.0.1 如果需要远程访问，则需要注释掉 守护进程 1daemonize no Redis默认以非守护进程运行，如果想要改为守护进程，则设置为yes pidfile 1pidfile /var/run/redis_6379.pid 设置当Redis以守护进程运行时，它的pid写入的文件 端口 1port 6379 指定Redis的端口 日志记录级别 1loglevel verbose Redis总共支持四个级别：debug, verbose, notice, warning, 默认为verbose 设置数据库个数 1databases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 1save &lt;seconds&gt; &lt;changes&gt; 默认配置文件提供三种操作 123save 900 1save 300 10save 60 10000 满足一个就持久化 指定本地数据库文件名，默认为dump.rdb 1dbfilename dump.rdb 指定本地数据库存放目录 1dir ./ 默认当前目录 主从服务 1slaveof &lt;masterip&gt; &lt;masterport&gt; 设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 master服务密码保护 1masterauth &lt;master-password&gt; 当master服务设置了密码保护时，slave服务连接master服务的密码 设置redis连接密码 1requirepass foobared 如果配置了连接密码，客户端在连接Redis时需要通过 AUTH &lt;password&gt;命令提供密码，默认关闭 Java连接redis必须设置密码 设置最大客户端连接数，默认无限制 1maxclients 10000 指定redis最大内存限制 1maxmemory &lt;bytes&gt; 建议根据服务器实际情况设置 建议不要超过1G 对于redis中的内存管理有两种方案： 为数据设置超时事件 采用LRU算法将不用的数据删除 volatile-lru: 设定超时时间的数据中，删除最不常使用的元素 allkeys-lru: 查询所有key中最近最不常使用的数据进行删除，应用最广泛 volatile-random: 在已经设定了超时的数据中随机删除 allkeys-random: 查询所有的key之后随机删除 volatile-ttl: 查询全部设定超时时间的数据，之后排序，将马上快要过期的数据进行删除操作 noevication: 不进行删除操作，内存溢出就报错返回 配置redis服务端 允许远程访问 注释掉 bind 127.0.0.1 以守护进程运行 将daemonize no 改为 daemonize yes Java 连接redis必须设置密码： requirepass &lt;password&gt; 查看redis是否在运行 1ps -ef | grep -i redis 远程连接redis 1redis-cli -h &lt;ip&gt; -p &lt;port&gt; -a &lt;password&gt;","link":"/2019/12/06/redis-conf/"},{"title":"redis基本配置及开关","text":"redis基本配置及开关 配置redis服务端 允许远程访问 注释掉 bind 127.0.0.1 以守护进程运行 将daemonize no 改为 daemonize yes Java 连接redis必须设置密码： requirepass &lt;password&gt; 查看redis是否在运行 1ps -ef | grep -i redis 远程连接redis 1redis-cli -h &lt;ip&gt; -p &lt;port&gt; -a &lt;password&gt; redis关闭 断电(非正常关闭，容易数据丢失) 查询PID: 123ps -ef | grep -i redis# Thenkill -9 &lt;PID&gt; 通过客户端关闭(正常关闭，数据保存) 1SHUTDOWN redis加载配置文件开启 1redis-server /usr/local/redis/redis.conf","link":"/2019/12/06/redis%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%BC%80%E5%85%B3/"},{"title":"validation-api","text":"validation-api JSR303/JSR-349，hibernate validator，spring validation之间的关系 JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate-validator是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的spring为了给开发者提供便捷，对hibernate validator进行了二次封装， 使用validation-api，通过注解形式进行数据校验 依赖包含关系 校验注解包含在spring-boot-starter-web里面 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 查看spring-boot-starter-web的子依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 子依赖中包含了spring-boot-starter-validation，再查看该依赖的子依赖： 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;jakarta.validation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.18.Final&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 可以发现，该子依赖中包含了validation-api，同时包含了它的实现hibernate-validator validation-api基本注解 限制 说明 @Null 限制只能为null @NotNull 限制必须不能为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @FutureOrPresent 限制必须是将来的日期或现在 @PastOrPresent 限制必须是过去的日期或现在 @Past 限制必须是一个过去的日期 @Min(value) 限制必须为一个不小于指定值的数字,@Min and @Max supports primitives and their wrappers. @Max(value) 限制必须为一个不大于指定值的数字 @Pattern(regrexp) 限制必须符合指定的正则表达式，通过regrexp指定正则表达式 @Size(max,min) 限制字符长度必须在min到max之间，supports String, Collection, Map and arrays @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格(The difference to @NotEmpty is that this constraint can only be applied on character sequences and that trailing white-spaces are ignored.) @Email(regrexp, flags) 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 注意 1. 对dto(@RequestBody)进行数据校验 直接在dto的类中的属性上加上校验注解。但是仅仅这样的话，该注解不会生效 需要在controller中需要校验的参数前加上@Validated注解： e.g. 123456@PostMapping(\"/register\")public ResultEntity register(@Validated @RequestBody CustomerRequest customerRequest){ customerService.register(customerRequest); return ResultEntity.succeed();} 2. 对GET请求的参数(@RequestParam)进行数据校验 对@RequestParam注解的参数通常没有专门的类，需要直接在controller方法的参数处加上校验注解： 123456@GetMapping(\"/check-code\") public ResultEntity sendCheckCode(@RequestParam @Email(message = \"必须为合法邮箱地址\") String email) { customerService.sendCheckCode(email); return ResultEntity.succeed(); } 仅仅这样，注解也不会生效。切记需要在controller类上加入@Validated注解才可以生效： 12345@Slf4j@RestController@Validated // 对@RequestParam的校验需要在controller上加@Validated注解@RequestMapping(\"/customer\")public class CustomerController { 官方文档 https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints","link":"/2019/12/23/validation-api/"},{"title":"Java-Map","text":"Java-Map 受到上篇C++ STL中map的排序方式的启发，这次又来探究一下Java中对于map的不同排序方式 依然分为两种排序 Sort By Key Sort By Value 打印map 打印map的元素使用以下的show()方法： 1234567public static void show(Map&lt;String, Integer&gt; map) { for (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) { System.out.println(entry.getKey() + \" \" + entry.getValue()); } System.out.println(\"=======================\"); System.out.println();} Sort By Value 升序 Java中对于Map的value进行排序依然需要借助其他容器，这里使用ArrayList 12345678910111213141516171819202122232425262728 /** * 获取按照value升序排序后的map * @param map 需要排序的map * @return 排好序的map */ public static Map&lt;String, Integer&gt; sortByValueAsc(Map&lt;String, Integer&gt; map) { List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); // 升序 Collections.sort(list, (e1, e2) -&gt; e1.getValue().compareTo(e2.getValue())); Map&lt;String, Integer&gt; sortedMap = new LinkedHashMap&lt;&gt;(); for (Map.Entry&lt;String, Integer&gt; entry: list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; }public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"boss\", 2); map.put(\"abuse\", 1); map.put(\"unit\", 3); map.put(\"duty\", 4); // 根据Value升序排序 System.out.println(\"🚀 SORT BY VALUE ASC:\"); Map&lt;String, Integer&gt; sortedMapAsc = sortByValueAsc(map); show(sortedMapAsc);} 这里将Map中的entry都放到了一个List中，然后使用自定义Comparator的方式对entry进行排序； 同时也使用了一种新的Map–LinkedHashMap LinkedHashMap是有序的，它会按照元素的插入顺序对元素进行排序 结果如下: 123456🚀 SORT BY VALUE ASC:abuse 1boss 2unit 3duty 4======================= 降序 同理，只是更换一下Comparator： 12345678910111213141516171819202122232425262728/** * 获取按照value降序排序后的map * @param map 需要排序的map * @return 排好序的map */ public static Map&lt;String, Integer&gt; sortByValueDesc(Map&lt;String, Integer&gt; map) { List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); // 降序 Collections.sort(list, (e1, e2) -&gt; e2.getValue().compareTo(e1.getValue())); Map&lt;String, Integer&gt; sortedMap = new LinkedHashMap&lt;&gt;(); for (Map.Entry&lt;String, Integer&gt; entry: list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"boss\", 2); map.put(\"abuse\", 1); map.put(\"unit\", 3); map.put(\"duty\", 4); // 根据Value降序排序 System.out.println(\"🚀 SORT BY VALUE DESC\"); Map&lt;String, Integer&gt; sortedMapDesc = sortByValueDesc(map); show(sortedMapDesc); } 结果如下: 123456🚀 SORT BY VALUE DESCduty 4unit 3boss 2abuse 1======================= Sort By Key 升序 对于key的排序也可以按照对value的排序一样，借助ArrayList和LinkedHashMap，但这里采用另一种方式，借助TreeMap进行排序 TreeMap是另一种Map，会对Map中的元素按照key大小进行排序 12345678910111213141516171819202122232425262728 /** * 通过TreeMap的方式对key按照升序排序 * @param map 要排序的map * @return 按照key升序排好序的map */ public static Map&lt;String, Integer&gt; sortByKeyByTreeMapAsc(Map&lt;String, Integer&gt; map) { /* The naturalOrder() method of Comparator Interface in Java returns a comparator that use to compare Comparable objects in natural order. */ Map&lt;String, Integer&gt; sortedMap = new TreeMap&lt;&gt;(Comparator.naturalOrder()); sortedMap.putAll(map); return sortedMap; }public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"boss\", 2); map.put(\"abuse\", 1); map.put(\"unit\", 3); map.put(\"duty\", 4); // 根据Key升序排序，使用TreeMap方式 System.out.println(\"🚀 SORT BY KEY ASC\"); Map&lt;String, Integer&gt; sortedByKeyAsc = sortByKeyByTreeMapAsc(map); show(sortedByKeyAsc); } 对Comparable对象的升序排序可以使用Comparator.naturalOrder()返回的Comparator来指定 执行的结果如下: 123456🚀 SORT BY KEY ASCabuse 1boss 2duty 4unit 3======================= 降序 同理，只是需要更改Comparator： 123456789101112131415161718192021222324252627/** * 通过TreeMap的方式对key按照将序排序 * @param map 要排序的map * @return 按照key降序排好序的map */public static Map&lt;String, Integer&gt; sortByKeyByTreeMapDesc(Map&lt;String, Integer&gt; map) { /* The reverseOrder() Returns a comparator that imposes the reverse of the natural ordering. */ Map&lt;String, Integer&gt; sortedMap = new TreeMap&lt;&gt;(Comparator.reverseOrder()); sortedMap.putAll(map); return sortedMap;}public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"boss\", 2); map.put(\"abuse\", 1); map.put(\"unit\", 3); map.put(\"duty\", 4); // 根据Key降序排序，使用TreeMap方式 System.out.println(\"🚀 SORT BY KEY DESC\"); Map&lt;String, Integer&gt; sortedByKeyDesc = sortByKeyByTreeMapDesc(map); show(sortedByKeyDesc);} 对Comparable对象的降序排序可以使用Comparator.reverseOrder()返回的Comparator来指定 结果如下: 123456🚀 SORT BY KEY DESCunit 3duty 4boss 2abuse 1======================= 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.util.*;/** * @author HavenTong * @date 2020/3/5 5:34 下午 */public class MapUtil { public static void show(Map&lt;String, Integer&gt; map) { for (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) { System.out.println(entry.getKey() + \" \" + entry.getValue()); } System.out.println(\"=======================\"); System.out.println(); } /** * 获取按照value升序排序后的map * @param map 需要排序的map * @return 排好序的map */ public static Map&lt;String, Integer&gt; sortByValueAsc(Map&lt;String, Integer&gt; map) { List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); // 升序 Collections.sort(list, (e1, e2) -&gt; e1.getValue().compareTo(e2.getValue())); Map&lt;String, Integer&gt; sortedMap = new LinkedHashMap&lt;&gt;(); for (Map.Entry&lt;String, Integer&gt; entry: list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } /** * 获取按照value降序排序后的map * @param map 需要排序的map * @return 排好序的map */ public static Map&lt;String, Integer&gt; sortByValueDesc(Map&lt;String, Integer&gt; map) { List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); // 降序 Collections.sort(list, (e1, e2) -&gt; e2.getValue().compareTo(e1.getValue())); Map&lt;String, Integer&gt; sortedMap = new LinkedHashMap&lt;&gt;(); for (Map.Entry&lt;String, Integer&gt; entry: list) { sortedMap.put(entry.getKey(), entry.getValue()); } return sortedMap; } /** * 通过TreeMap的方式对key按照升序排序 * @param map 要排序的map * @return 按照key升序排好序的map */ public static Map&lt;String, Integer&gt; sortByKeyByTreeMapAsc(Map&lt;String, Integer&gt; map) { /* The naturalOrder() method of Comparator Interface in Java returns a comparator that use to compare Comparable objects in natural order. */ Map&lt;String, Integer&gt; sortedMap = new TreeMap&lt;&gt;(Comparator.naturalOrder()); sortedMap.putAll(map); return sortedMap; } /** * 通过TreeMap的方式对key按照将序排序 * @param map 要排序的map * @return 按照key降序排好序的map */ public static Map&lt;String, Integer&gt; sortByKeyByTreeMapDesc(Map&lt;String, Integer&gt; map) { /* The reverseOrder() Returns a comparator that imposes the reverse of the natural ordering. */ Map&lt;String, Integer&gt; sortedMap = new TreeMap&lt;&gt;(Comparator.reverseOrder()); sortedMap.putAll(map); return sortedMap; } public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"boss\", 2); map.put(\"abuse\", 1); map.put(\"unit\", 3); map.put(\"duty\", 4); // 根据Value升序排序 System.out.println(\"🚀 SORT BY VALUE ASC:\"); Map&lt;String, Integer&gt; sortedMapAsc = sortByValueAsc(map); show(sortedMapAsc); // 根据Value降序排序 System.out.println(\"🚀 SORT BY VALUE DESC\"); Map&lt;String, Integer&gt; sortedMapDesc = sortByValueDesc(map); show(sortedMapDesc); // 根据Key升序排序，使用TreeMap方式 System.out.println(\"🚀 SORT BY KEY ASC\"); Map&lt;String, Integer&gt; sortedByKeyAsc = sortByKeyByTreeMapAsc(map); show(sortedByKeyAsc); // 根据Key降序排序，使用TreeMap方式 System.out.println(\"🚀 SORT BY KEY DESC\"); Map&lt;String, Integer&gt; sortedByKeyDesc = sortByKeyByTreeMapDesc(map); show(sortedByKeyDesc); }}","link":"/2020/03/05/Java-Map/"},{"title":"Serializable接口","text":"Serializable接口 Serializable接口概述 Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。 而这一点对于面向对象的编程语言来说是非常重要的，因为无论什么编程语言，其底层涉及IO操作的部分还是由操作系统其帮其完成的，而底层IO操作都是以字节流的方式进行的，所以写操作都涉及将编程语言数据类型转换为字节流，而读操作则又涉及将字节流转化为编程语言类型的特定数据类型。而Java作为一门面向对象的编程语言，对象作为其主要数据的类型载体，为了完成对象数据的读写操作，也就需要一种方式来让JVM知道在进行IO操作时如何将对象数据转换为字节流，以及如何将字节流数据转换为特定的对象，而Serializable接口就承担了这样一个角色。 下面我们可以通过例子来实现将序列化的对象存储到文件，然后再将其从文件中反序列化为对象，代码示例如下： 先定义一个序列化对象User： 1234567891011public class User implements Serializable { private static final long serialVersionUID = 1L; private String userId; private String userName; public User(String userId, String userName) { this.userId = userId; this.userName = userName; } } 然后我们编写测试类，来对该对象进行读写操作，我们先测试将该对象写入一个文件： 1234567891011121314151617181920public class SerializableTest { /** * 将User对象作为文本写入磁盘 */ public static void writeObj() { User user = new User(\"1001\", \"Joe\"); try { ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"/Users/guanliyuan/user.txt\")); objectOutputStream.writeObject(user); objectOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } public static void main(String args[]) { writeObj(); } } 运行上述代码，我们就将User对象及其携带的数据写入了文本user.txt中，我们可以看下user.txt中存储的数据此时是个什么格式： 12345java.io.NotSerializableException: cn.wudimanong.serializable.User at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) at cn.wudimanong.serializable.SerializableTest.writeObj(SerializableTest.java:19) at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:27) 我们看到对象数据以二进制文本的方式被持久化到了磁盘文件中。在进行反序列化测试之前，我们可以尝试下将User实现Serializable接口的代码部分去掉，看看此时写操作是否还能成功，结果如下： 结果不出所料，果然是不可以的，抛出了NotSerializableException异常，提示非可序列化异常，也就是说没有实现Serializable接口的对象是无法通过IO操作持久化的。 接下来，我们继续编写测试代码，尝试将之前持久化写入user.txt文件的对象数据再次转化为Java对象，代码如下： 123456789101112131415161718192021222324public class SerializableTest { /** * 将类从文本中提取并赋值给内存中的类 */ public static void readObj() { try { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"/Users/guanliyuan/user.txt\")); try { Object object = objectInputStream.readObject(); User user = (User) object; System.out.println(user); } catch (ClassNotFoundException e) { e.printStackTrace(); } } catch (IOException e) { e.printStackTrace(); } } public static void main(String args[]) { readObj(); } } 通过反序列化操作，可以再次将持久化的对象字节流数据通过IO转化为Java对象，结果如下： 1cn.wudimanong.serializable.User@6f496d9f 此时，如果我们再次尝试将User实现Serializable接口的代码部分去掉，发现也无法再文本转换为序列化对象，报错信息为： 12345678ava.io.InvalidClassException: cn.wudimanong.serializable.User; class invalid for deserialization at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:157) at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:862) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2038) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:428) at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:31) at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:44) 提示非法类型转换异常，说明在Java中如何要实现对象的IO读写操作，都必须实现Serializable接口，否则代码就会报错! 序列化&amp;反序列化 通过上面的阐述和示例，相信大家对Serializable接口的作用是有了比较具体的体会了，接下来我们上层到理论层面，看下到底什么是序列化/反序列化。序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。 而反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。那么什么情况下需要序列化呢? 大概有这样两类比较常见的场景： 需要把内存中的对象状态数据保存到一个文件或者数据库中的时候，这个场景是比较常见的，例如我们利用mybatis框架编写持久层insert对象数据到数据库中时 网络通信时需要用套接字在网络中传送对象时，如我们使用RPC协议进行网络通信时 关于serialVersionUID 对于JVM来说，要进行持久化的类必须要有一个标记，只有持有这个标记JVM才允许类创建的对象可以通过其IO系统转换为字节数据，从而实现持久化，而这个标记就是Serializable接口。而在反序列化的过程中则需要使用serialVersionUID来确定由那个类来加载这个对象，所以我们在实现Serializable接口的时候，一般还会要去尽量显示地定义serialVersionUID，如： 1private static final long serialVersionUID = 1L; 在反序列化的过程中，如果接收方为对象加载了一个类，如果该对象的serialVersionUID与对应持久化时的类不同，那么反序列化的过程中将会导致InvalidClassException异常。例如，在之前反序列化的例子中，我们故意将User类的serialVersionUID改为2L，如： 1private static final long serialVersionUID = 2L; 那么此时，在反序例化时就会导致异常，如下： 123456789java.io.InvalidClassException: cn.wudimanong.serializable.User; local class incompatible: stream classdesc serialVersionUID = 1, local class serialVersionUID = 2 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:687) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1880) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1746) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2037) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1568) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:428) at cn.wudimanong.serializable.SerializableTest.readObj(SerializableTest.java:31) at cn.wudimanong.serializable.SerializableTest.main(SerializableTest.java:44) 如果我们在序列化中没有显示地声明serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的serialVersionUID值。但是，Java官方强烈建议所有要序列化的类都显示地声明serialVersionUID字段，因为如果高度依赖于JVM默认生成serialVersionUID，可能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的InvalidClassException异常。因此，为了保证跨不同Java编译器实现的serialVersionUID值的一致，实现Serializable接口的必须显示地声明serialVersionUID字段。 此外serialVersionUID字段地声明要尽可能使用private关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子类继承是没有用处的!有个特殊的地方需要注意的是，数组类是不能显示地声明serialVersionUID的，因为它们始终具有默认计算的值，不过数组类反序列化过程中也是放弃了匹配serialVersionUID值的要求。","link":"/2019/11/19/Serializable%E6%8E%A5%E5%8F%A3/"},{"title":"Spring Boot-JDBC","text":"Spring Boot &amp; JDBC 1. Spring Boot整合JDBC操作数据库 JDBC操作数据库流程 加载数据库驱动 建立数据库连接 创建数据库操作对象 定义操作的SQL语句 执行数据库操作 获取并操作结果集 关闭对象，回收资源 不建议使用JDBC 将Spring JDBC整合到Spring Boot pom.xml引入依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; 修改application.yml 123456spring: datasource: url: jdbc:mysql://localhost:3306/jdbc username: root password: Thwf1858 driver-class-name: com.mysql.jdbc.Driver DAO层代码 jdbcTemplate.update适用于insert, update和delete操作 jdbcTemplate.queryForObject用于查询单条记录并返回结果 jdbcTemplate.query用于查询结果列表 BeanPropertyRowMapper可以将数据库字段的值向数据库映射，满足驼峰标识也可以自动映射 e.x. 数据库create_time映射到createTime属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.haven.dao;import com.fasterxml.jackson.databind.BeanProperty;import com.haven.model.Article;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import java.util.List;/** * @author HavenTong * @date 2019/10/30 10:39 下午 */@Repository // @Repository标注持久层 public class ArticleJDBCDAO { @Resource private JdbcTemplate jdbcTemplate; // 保存文章 public void save(Article article){ jdbcTemplate.update(\"INSERT INTO article(author, title, content, create_time) values (?,?,?,?)\", article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime()); } // 删除文章 // 传参可以用 new Object[]{}传，也可以一个一个设置 public void deleteById(int id){ jdbcTemplate.update(\"DELETE FROM article WHERE id=?\", new Object[]{id}); } // 更新文章 public void updateById(Article article){ jdbcTemplate.update(\"UPDATE article SET author=?, title=?, content=?, create_time=? WHERE id=?\", article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime(), article.getId()); } // 根据id查找文章 public Article findById(int id){ return (Article)jdbcTemplate.queryForObject(\"SELECT * FROM article WHERE id = ?\", new Object[]{id}, new BeanPropertyRowMapper(Article.class)); } // 查询所有 public List&lt;Article&gt; findAll(){ return (List&lt;Article&gt;) jdbcTemplate.query(\"SELECT * FROM article\", new BeanPropertyRowMapper(Article.class)); }} 2. JDBC多数据源 (1) application.yml配置两个数据源，第一个叫primary, 第二个叫secondar,也可以自己取名: 1234567891011121314151617server: port: 8080spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 datasource: primary: jdbc-url: jdbc:mysql://localhost:3306/jdbc username: root password: Thwf1858 driver-class-name: com.mysql.jdbc.Driver secondary: jdbc-url: jdbc:mysql://localhost:3306/test username: root password: Thwf1858 driver-class-name: com.mysql.jdbc.Driver (2) 通过Java Config将数据源注入到Spring上下文 primaryJdbcTemplate使用primaryDataSource数据源操作数据库jdbc secondaryJdbcTemplate使用secondaryDataSource数据源操作数据库test DataSourceConfig.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.haven.config;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import javax.xml.crypto.Data;/** * @author HavenTong * @date 2019/10/31 12:08 上午 */@Configurationpublic class DataSourceConfig { @Primary @Bean(name = \"primaryDataSource\") @Qualifier(\"primaryDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.primary\") public DataSource primaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = \"secondaryDataSource\") @Qualifier(\"secondaryDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.secondary\") public DataSource secondaryDataSource(){ return DataSourceBuilder.create().build(); } @Bean(name = \"primaryJdbcTemplate\") public JdbcTemplate primaryJdbcTemplate( @Qualifier(\"primaryDataSource\") DataSource dataSource ){ return new JdbcTemplate(dataSource); } @Bean(name = \"secondaryJdbcTemplate\") public JdbcTemplate secondaryTemplate( @Qualifier(\"secondaryDataSource\") DataSource dataSource){ return new JdbcTemplate(dataSource); }} (3) 之后修改dao层代码: ArticleJDBCDAO.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.haven.dao;import com.fasterxml.jackson.databind.BeanProperty;import com.haven.model.Article;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import javax.annotation.Resource;import java.util.List;/** * @author HavenTong * @date 2019/10/30 10:39 下午 */@Repositorypublic class ArticleJDBCDAO { // 保存文章 public void save(Article article, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\"INSERT INTO article(author, title, content, create_time) values (?,?,?,?)\", article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime()); } // 删除文章 public void deleteById(int id, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\"DELETE FROM article WHERE id=?\", new Object[]{id}); } // 更新文章 public void updateById(Article article, JdbcTemplate jdbcTemplate){ jdbcTemplate.update(\"UPDATE article SET author=?, title=?, content=?, create_time=? WHERE id=?\", article.getAuthor(), article.getTitle(), article.getContent(), article.getCreateTime(), article.getId()); } // 根据id查找文章 public Article findById(int id, JdbcTemplate jdbcTemplate){ return (Article)jdbcTemplate.queryForObject(\"SELECT * FROM article WHERE id = ?\", new Object[]{id}, new BeanPropertyRowMapper(Article.class)); } // 查询所有 public List&lt;Article&gt; findAll(JdbcTemplate jdbcTemplate){ return (List&lt;Article&gt;) jdbcTemplate.query(\"SELECT * FROM article\", new BeanPropertyRowMapper(Article.class)); }} (4) 修改service层代码 ArticleRestJDBCServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.haven.service;import com.haven.dao.ArticleJDBCDAO;import com.haven.model.Article;import lombok.extern.slf4j.Slf4j;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;import java.util.List;/** * @author HavenTong * @date 2019/10/30 10:56 下午 */@Slf4j@Servicepublic class ArticleRestJDBCServiceImpl implements ArticleRestService { @Resource ArticleJDBCDAO articleJDBCDAO; @Resource JdbcTemplate primaryJdbcTemplate; @Resource JdbcTemplate secondaryJdbcTemplate; @Transactional @Override public Article saveArticle(Article article) { articleJDBCDAO.save(article, primaryJdbcTemplate); articleJDBCDAO.save(article, secondaryJdbcTemplate); return article; } @Override public void deleteArticle(int id) { articleJDBCDAO.deleteById(id, primaryJdbcTemplate); articleJDBCDAO.deleteById(id, secondaryJdbcTemplate); } @Override public void updateArticle(Article article) { articleJDBCDAO.updateById(article, primaryJdbcTemplate); } @Override public Article getArticle(int id) { return articleJDBCDAO.findById(id, primaryJdbcTemplate); } @Override public List&lt;Article&gt; getAll() { return articleJDBCDAO.findAll(primaryJdbcTemplate); }} 3. Spring JDBC JTA实现分布式事务 @Transactional无法跨库完成分布式事务 通过整合JTA实现分布式事务 引入maven依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jta-atomikos --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改application.yml配置文件 12345678910111213141516171819202122primarydb: uniqueResourceName: primary xaDataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource xaProperties: url: jdbc:mysql://localhost:3306/jdbc user: root password: Thwf1858 exclusiveConnectionMode: true minPoolSize: 3 maxPoolSize: 10 testQuery: SELECT 1 FROM dualsecondarydb: uniqueResourceName: secondary xaDataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource xaProperties: url: jdbc:mysql://localhost:3306/test user: root password: Thwf1858 exclusiveConnectionMode: true minPoolSize: 3 maxPoolSize: 10 testQuery: SELECT 1 FROM dual 编写配置类DataSourceConfig.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.haven.config;import com.atomikos.jdbc.AtomikosDataSourceBean;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import javax.xml.crypto.Data;/** * @author HavenTong * @date 2019/10/31 12:08 上午 */@Configurationpublic class DataSourceConfig { // 多数据源，分布式 @Bean(initMethod = \"init\", destroyMethod = \"close\", name = \"primaryDataSource\") @Primary @ConfigurationProperties(prefix = \"primarydb\") public DataSource primaryDataSource(){ return new AtomikosDataSourceBean(); } @Bean(initMethod = \"init\", destroyMethod = \"close\", name = \"secondaryDataSource\") @ConfigurationProperties(prefix = \"secondarydb\") public DataSource secondaryDataSource(){ return new AtomikosDataSourceBean(); } @Bean public JdbcTemplate primaryJdbcTemplate(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource){ return new JdbcTemplate(primaryDataSource); } @Bean public JdbcTemplate secondaryJdbcTemplate(@Qualifier(\"secondaryDataSource\") DataSource secondaryDataSource){ return new JdbcTemplate(secondaryDataSource); }} 配置事务管理器™ TransactionManagerConfig.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.haven.config;import com.atomikos.icatch.jta.UserTransactionImp;import com.atomikos.icatch.jta.UserTransactionManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.jta.JtaTransactionManager;import javax.transaction.SystemException;import javax.transaction.TransactionManager;import javax.transaction.UserTransaction;/** * @author HavenTong * @date 2019/10/31 3:57 下午 */@Configurationpublic class TransactionManagerConfig { @Bean public UserTransaction userTransaction() throws SystemException { UserTransactionImp userTransactionImp = new UserTransactionImp(); userTransactionImp.setTransactionTimeout(10000); return userTransactionImp; } @Bean(name = \"atomikosTransactionManager\", initMethod = \"init\", destroyMethod = \"close\") public TransactionManager atomikosTransactionManager() throws Throwable{ UserTransactionManager userTransactionManager = new UserTransactionManager(); userTransactionManager.setForceShutdown(false); return userTransactionManager; } @Bean(name = \"transactionManager\") @DependsOn({\"userTransaction\", \"atomikosTransactionManger\"}) public PlatformTransactionManager transactionManager() throws Throwable{ UserTransaction userTransaction = userTransaction(); JtaTransactionManager manager = new JtaTransactionManager(userTransaction, atomikosTransactionManager()); return manager; }}","link":"/2019/10/31/Spring-Boot-JDBC/"},{"title":"SpringBoot配置","text":"Spring Boot配置 1. 标记语言 以前的配置文件：xxx.xml YAML: 以数据为中心，比json, xml更适合作配置文件，实例如下 12server: port: 8081 XML: 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2. YAML语法 (1) 基本语法 K :(空格)V — 表示一对键值对 以空格的缩进来控制层级关系，左对齐的一列数据都是同一层级 123server: port: 8080 path: /hello 属性和值大小写敏感 (2) 值的写法 字面量：普通的值(数字，字符串，布尔) k: v: 字面量直接来写 ​ 字符串默认不需要加上单引号或双引号 ​ 双引号：不会转义字符串里的特殊字符；特殊字符会作为本身想表示的意思 ​ name: &quot;zhangsan \\n lisi&quot;输出zhangsan 换行 lisi ​ 单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串 ​ name: &quot;zhangsan \\n lisi&quot;输出zhangsan \\n lisi 对象(属性和值): 键值对 k: v: 对象还是k: v的模式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: {lastName: zhangsan, age: 18} 数组(List, Set) 用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat, dog, pig ] 3. 配置文件值注入 配置文件： 123456789101112131415server: port: 8081person: lastName: zhangsan age: 18 boss: false birthDay: 2017/12/12 maps: {k1: v1, k2: 12} list: - lisi - zhaoliu dog: name: myDog age: 2 javaBean: 123456789101112131415161718/** 将配置文件中配置的每一个属性的值，映射到这个组件中* @ConfigurationProperties：告诉Spring Boot将本类中的所有属性和配置文件中相关的配置进行绑定* prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射** 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能* */@Component@ConfigurationProperties(prefix = \"person\")public class Person { private String lastName; private Integer age; private Boolean boss; private Date birthDay; private Dog dog; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; list; 我们可以导入配置文件处理器，以后配置文件进行绑定就可以有提示： 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; @ConfigurationProperties获取值和@Value获取值的区别 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个一个指定 松散绑定(松散语法) 支持松散语法绑定 不支持松散语法绑定 SpEL 不支持 支持 JSR30数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml和properties都可以获取值 如果只是在某个业务逻辑中，需要获取一下某个配置文件中的某项值，使用@Value 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties 配置文件注入值数据校验 1234567@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person { // lastName必须为邮箱格式 @Email private String lastName; 4. @PropertySource&amp;ImportResource @PropertySource：加载指定的配置文件 123456789/** @ConfigurationProperties(prefix = \"person\")* 默认从全局配置文件中获取值* */@PropertySource(value = {\"classpath:person.properties\"})@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person { @ImportResource：导入Spring的配置文件，让配置文件中的内容生效 Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来； 需要将@ImportResource标注在一个配置类上 123456789@ImportResource(locations = {\"classpath:beans.xml\"})@SpringBootApplicationpublic class SpringBoot01HelloworldQuickApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot01HelloworldQuickApplication.class, args); }} 导入Spring的配置文件，让其生效 但不希望编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.haven.springboot.sevice.HelloService\" id=\"helloService\"&gt; &lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式： 推荐使用全注解方式 配置类===Spring配置文件 使用@Bean给容器中添加组件 1234567891011121314151617/** @Configuration：告诉Spring Boot这是一个配置类* 就是来替代之前Spring的配置文件** 之前在Spring配置文件中用 &lt;bean&gt;&lt;/bean&gt; 标签添加组件* */@Configurationpublic class MyAppConfig { // 将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(\"配置类@Bean给容器中添加组件\"); return new HelloService(); }} 5. 配置文件占位符 (1) 随机数 12${random.value}, ${random.int}, ${random.long}${random.int(10)}, ${random.int[1024, 65536]} (2) 占位符获取之前配置的值，如果没有可以使用:指定默认值 123456789person.last-name=张三${random.uuid}person.age=${random.int}person.birth-day=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.list=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15 6. Profile (1) 多Profile文件 我们在主配置文件编写时，文件名可以是application-{profile}.properties/yml 默认使用application.properties的配置 (2)激活指定profile 在配置文件中指定spring.profiles.active=dev 命令行 1--spring.profiles.active=dev Edit Configuration—&gt;Program arguments (3) yml多文档块 123456789101112131415161718server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于那个环境 7. 配置文件加载位置 优先级由高到低，高优先级会覆盖低优先级的配置： ./config/ ./ ./src/main/resources/config/ ./src/main/resources/ SpringBoot会从这四个位置全部加载主配置文件：互补配置 可以通过spring.config.location来改变默认的配置文件的位置 项目打包好后，可以使用命令行参数--spring.config.location=?的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用，形成互补配置 8. 自动配置原理 配置文件能配置的属性参照 https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/common-application-properties.html 自动配置原理 SpringBoot启动时加载主配置类，开启了自动配置功能@EnableAutoConfiguration @EnableAutoConfiguration原理 利用AutoConfigurationImportSelector给容器中导入一些组件 查看AutoConfigurationImportSelector中的selectImports()方法 12// 获取候选的配置List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 12// getCandidateConfigurations()List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); 1234SpringFactoriesLoader.loadFactoryNames()// 扫描所有jar包类路径下的 META-INF/spring.factories// 把扫描到的文件的内容包装成properties对象// 从properties获取到EnableAutoConfiguration.class的类名对应的值，然后把他们添加在容器中 将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加到了容器中 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们做自动配置。 每一个自动配置类进行自动配置功能 HttpEncodingAutoConfiguration(HTTP编码自动配置)为例，介绍自动配置原理 12345678910111213141516171819202122232425262728293031323334353637@Configuration // 表示是一个配置类，可以给容器中添加组件@EnableConfigurationProperties({HttpProperties.class}) // 启用指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpProperties绑定起来，并把HttpProperties加入到ioc容器中@ConditionalOnWebApplication( type = Type.SERVLET) // Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；// 判断当前应用是否是web应用，如果是，则当前配置类生效；// 判断当前项目有没有这个类// CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器@ConditionalOnClass({CharacterEncodingFilter.class})// 判断配置文件中是否存在某个配置 spring.http.encoding;如果不存在，判断也是成立的// 即使配置文件中不配置spring.http.encoding=enabled，也是默认生效的@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { // 他已经和SpringBoot的配置文件映射了 private final Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } @Bean // 给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效。 一旦配置类生效，这个配置类就会个容器中添加各种组件，这些组件是从对应的properties类中获取的，而这些类里面的每一个属性又是和配置文件绑定的。 所有在配置文件中能配置的属性，都是在xxxProperties类中封装着；配置文件能配置什么，就可以参照某个功能对应的属性类 1234@ConfigurationProperties( prefix = \"spring.http\") // 从配置文件中获取指定的值和bean的属性进行绑定public class HttpProperties { 精髓 SpringBoot启动会加载大量的配置类 我们看我们的功能有没有SpringBoot默认写好的自动配置类； 再看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置） 给容器中自动配置类添加组件时，会从propertie中获取某些属性，我们就可以在配置文件中指定这些属性的值 xxxAutoConfiguration：自动配置类，给容器中添加组件 xxxProperties：封装配置文件中相关属性 9. 细节 1. @Conditional派生注解 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置类里面的所有内容才生效 自动配置类必须在一定的条件下才能生效 通过 1debug=true 让控制台打印自动配置报告，这样我们就可以很方便地知道哪些自动配置类生效 分为Positive matches和Negative matches","link":"/2019/09/28/SpringBoot%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Moment","slug":"Moment","link":"/tags/Moment/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[]}